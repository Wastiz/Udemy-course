'use strict';

//Смысл генератора в том, что когда мы вызываем функцию несколько раз, результаты жтой функции разные

function* generator (){ //Вот такой вот синтакиси у нее
    yield 'S'; //В каждом из этих полей прописывается функционал, то есть что при каждом вызове будет выполняться
    yield 'C';
    yield 'D';
    yield 'V';
}


const str = generator(); //Потом нужно обернуть генератор в функцию, чтобы вызывать
console.log(str);// Если запускаем без next, то получаем просто пустой объект
console.log(str.next().value);//А вот здесь прописываем next, чтобы выполнялись следующие поля
console.log(str.next().done);
console.log(str.next());
console.log(str.next());
console.log(str.next()); 

//Как мы видим, в консоли мы получаем объект, в котором собственно результат и булиновое значение.
//Это значение показывает выполнились все поля в генераторе
//Но как мы видим нужно функцию выолнить еще раз после всех полей, чтобы в done было true

function* count (n) {
    for (let i  = 0; i < n; i++){
        yield i;
    } 
}

for (let k of count(7)) {
    console.log(k);
} //С помощью этой конструкции можно сразу запусть сколько нужно генератор

const counter = count(7);

console.log(counter.next().value);

//Прикол этой функции в том, что цикл выполняется один раз, а генератор при этом ждет когда пропишется next.
//Соответственно эта функция будет выполнена когда дойдет до 7